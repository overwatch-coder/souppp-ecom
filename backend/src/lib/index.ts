import crypto from "crypto";
import { Response } from "express";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";
import {
  getVerificationCodeEmailContent,
  getVerificationSuccessEmailContent,
} from "@/constants/email";
import { sendEmail } from "@/lib/sendEmail";
import Code from "@/models/code.model";
import { createHttpError, HttpStatusCode } from "@/middleware/error.middleware";

// generate jwt token and send cookie
export const generateToken = (res: Response, userId: string) => {
  const token = jwt.sign({ userId }, process.env.JWT_SECRET as string, {
    expiresIn: "14d",
  });

  res.cookie("access_token", token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    maxAge: 1000 * 60 * 60 * 24 * 14, // 14 days
  });
};

// compare password with db password
export const comparePassword = async (
  password: string,
  hashedPassword: string
) => {
  return bcrypt.compare(password, hashedPassword);
};


// Function to generate unique random 6-digit codes
export const generateVerificationCode = (codeLength: number = 6) => {
  const charset = "0123456789"; // Characters to be used in the code
  let code = "";

  for (let i = 0; i < codeLength; i++) {
    const randomIndex = crypto.randomInt(0, charset.length); // Generate random index
    code += charset[randomIndex]; // Append random character from charset to code
  }

  return code;
};

// send verification email
export const sendVerificationEmail = async (
  email: string,
  userId: string,
  name: string = "User",
  type: string = "registration",
  resetPassword: boolean = false,
  subject?: string,
  content?: string,
  code?: string
) => {
  try {
    // remove any previous verification code generated by the user
    resetPassword
      ? await Code.deleteMany({ $and: [{ userId }, { type: "PASSWORD" }] })
      : await Code.deleteMany({ $and: [{ userId }, { type: "EMAIL" }] });

    // generate verification code
    const verificationCode = code ? code : generateVerificationCode();
    const codeHash = await bcrypt.hash(verificationCode, 10);
    const token = jwt.sign(
      { codeHash, email },
      process.env.JWT_SECRET as string,
      {
        expiresIn: "10m",
      }
    );

    // hash and save it into the dataVerificationCodebase
    const saveVerificationCode = await Code.create({
      userId,
      codeHash,
      token,
      type: resetPassword ? "PASSWORD" : "EMAIL",
    });

    if (!saveVerificationCode) {
      throw createHttpError(
        "Verification code creation failed",
        HttpStatusCode.InternalServerError
      );
    }

    // if successfully saved, send the verification code to the user
    const emailSubject = subject ? subject : "Verify Your Account | Souppp";
    const emailContent = content
      ? content
      : getVerificationCodeEmailContent(verificationCode, name, type);

    const messageId = await sendEmail(email, emailSubject, emailContent);
    console.log({ message: messageId });
  } catch (error: any) {
    throw createHttpError(error.message, HttpStatusCode.InternalServerError);
  }
};

// send confirmation email after verification successful
export const sendConfirmationEmail = async (
  email: string,
  name: string,
  subject?: string,
  content?: string
) => {
  const emailSubject = subject
    ? subject
    : "Account Successfully Verified | Souppp";
  const emailContent = content
    ? content
    : getVerificationSuccessEmailContent(name);
  const messageId = await sendEmail(email, emailSubject, emailContent);
  console.log({ message: messageId });
};
